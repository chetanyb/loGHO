var X = (e, t, r) => {
  if (!t.has(e))
    throw TypeError("Cannot " + r);
};
var w = (e, t, r) => (X(e, t, "read from private field"), r ? r.call(e) : t.get(e)), R = (e, t, r) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, r);
}, I = (e, t, r, n) => (X(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r);
var k = (e, t, r) => (X(e, t, "access private method"), r);
var we = /* @__PURE__ */ ((e) => (e.eur = "eur", e))(we || {}), ye = /* @__PURE__ */ ((e) => (e.corporate = "corporate", e.personal = "personal", e))(ye || {}), me = /* @__PURE__ */ ((e) => (e.read = "read", e.write = "write", e))(me || {}), _e = /* @__PURE__ */ ((e) => (e.absent = "absent", e.submitted = "submitted", e.pending = "pending", e.confirmed = "confirmed", e))(_e || {}), be = /* @__PURE__ */ ((e) => (e.approved = "approved", e.rejected = "rejected", e.unknown = "unknown", e))(be || {}), Se = /* @__PURE__ */ ((e) => (e.requested = "requested", e.approved = "approved", e.pending = "pending", e))(Se || {}), Be = /* @__PURE__ */ ((e) => (e.iban = "iban", e.scan = "scan", e.chain = "chain", e))(Be || {}), ke = /* @__PURE__ */ ((e) => (e.redeem = "redeem", e.issue = "issue", e))(ke || {}), Ce = /* @__PURE__ */ ((e) => (e.placed = "placed", e.pending = "pending", e.processed = "processed", e.rejected = "rejected", e))(Ce || {});
const re = (e) => {
  if (e.toString() === "Invalid Date")
    throw e;
  const t = (n) => n < 10 ? "0" + n : n, r = (n) => {
    if (n === 0)
      return "Z";
    const u = n > 0 ? "-" : "+";
    return n = Math.abs(n), u + t(Math.floor(n / 60)) + ":" + t(n % 60);
  };
  return e.getFullYear() + "-" + t(e.getMonth() + 1) + "-" + t(e.getDate()) + "T" + t(e.getHours()) + ":" + t(e.getMinutes()) + ":" + t(e.getSeconds()) + r(e.getTimezoneOffset());
}, Fe = (e, t, r, n) => {
  const u = `${(n == null ? void 0 : n.toUpperCase()) || "EUR"}`;
  return r ? `Send ${u} ${e} to ${t} on ${ee(
    r
  )} at ${re(/* @__PURE__ */ new Date())}` : `Send ${u} ${e} to ${t} at ${re(/* @__PURE__ */ new Date())}`;
}, Z = (e) => {
  var t;
  return e && ((t = Object.entries(e)) == null ? void 0 : t.length) > 0 ? Object.entries(e).map(
    ([r, n]) => `${encodeURIComponent(r)}=${encodeURIComponent(n)}`
  ).join("&") : "";
}, ee = (e) => {
  switch (e) {
    case 1:
    case 5:
      return "ethereum";
    case 100:
    case 10200:
      return "gnosis";
    case 137:
    case 80001:
      return "polygon";
    default:
      throw new Error(`Chain not supported: ${e}`);
  }
}, ae = (e) => {
  switch (e) {
    case 1:
    case 100:
    case 137:
      return "mainnet";
    case 5:
      return "goerli";
    case 10200:
      return "chiado";
    case 80001:
      return "mumbai";
    default:
      throw new Error(`Network not supported: ${e}`);
  }
}, Q = (e) => {
  if (e != null && e.chainId) {
    const { chainId: t, ...r } = e;
    return {
      ...r,
      chain: ee(t),
      network: ae(t)
    };
  }
  return e;
}, K = {
  environments: {
    production: {
      api: "https://api.monerium.app",
      web: "https://monerium.app",
      wss: "wss://api.monerium.app"
    },
    sandbox: {
      api: "https://api.monerium.dev",
      web: "https://sandbox.monerium.dev",
      wss: "wss://api.monerium.dev"
    }
  }
}, xe = "I hereby declare that I am the address owner.", M = "monerium.sdk.code_verifier", D = "monerium.sdk.refresh_token", We = {
  LINK_MESSAGE: xe,
  STORAGE_CODE_VERIFIER: M,
  STORAGE_REFRESH_TOKEN: D
};
var q = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ce(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Ae(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var u = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, u.get ? u : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
var ue = { exports: {} };
function Ee(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Y = { exports: {} };
const Ie = {}, $e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Ie
}, Symbol.toStringTag, { value: "Module" })), Re = /* @__PURE__ */ Ae($e);
var ne;
function he() {
  return ne || (ne = 1, function(e, t) {
    (function(r, n) {
      e.exports = n();
    })(q, function() {
      var r = r || function(n, u) {
        var c;
        if (typeof window < "u" && window.crypto && (c = window.crypto), typeof self < "u" && self.crypto && (c = self.crypto), typeof globalThis < "u" && globalThis.crypto && (c = globalThis.crypto), !c && typeof window < "u" && window.msCrypto && (c = window.msCrypto), !c && typeof q < "u" && q.crypto && (c = q.crypto), !c && typeof Ee == "function")
          try {
            c = Re;
          } catch {
          }
        var v = function() {
          if (c) {
            if (typeof c.getRandomValues == "function")
              try {
                return c.getRandomValues(new Uint32Array(1))[0];
              } catch {
              }
            if (typeof c.randomBytes == "function")
              try {
                return c.randomBytes(4).readInt32LE();
              } catch {
              }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }, B = Object.create || function() {
          function o() {
          }
          return function(s) {
            var a;
            return o.prototype = s, a = new o(), o.prototype = null, a;
          };
        }(), p = {}, y = p.lib = {}, m = y.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(o) {
              var s = B(this);
              return o && s.mixIn(o), (!s.hasOwnProperty("init") || this.init === s.init) && (s.init = function() {
                s.$super.init.apply(this, arguments);
              }), s.init.prototype = s, s.$super = this, s;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var o = this.extend();
              return o.init.apply(o, arguments), o;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(o) {
              for (var s in o)
                o.hasOwnProperty(s) && (this[s] = o[s]);
              o.hasOwnProperty("toString") && (this.toString = o.toString);
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }(), g = y.WordArray = m.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(o, s) {
            o = this.words = o || [], s != u ? this.sigBytes = s : this.sigBytes = o.length * 4;
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(o) {
            return (o || f).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(o) {
            var s = this.words, a = o.words, h = this.sigBytes, _ = o.sigBytes;
            if (this.clamp(), h % 4)
              for (var S = 0; S < _; S++) {
                var C = a[S >>> 2] >>> 24 - S % 4 * 8 & 255;
                s[h + S >>> 2] |= C << 24 - (h + S) % 4 * 8;
              }
            else
              for (var x = 0; x < _; x += 4)
                s[h + x >>> 2] = a[x >>> 2];
            return this.sigBytes += _, this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var o = this.words, s = this.sigBytes;
            o[s >>> 2] &= 4294967295 << 32 - s % 4 * 8, o.length = n.ceil(s / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var o = m.clone.call(this);
            return o.words = this.words.slice(0), o;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(o) {
            for (var s = [], a = 0; a < o; a += 4)
              s.push(v());
            return new g.init(s, o);
          }
        }), b = p.enc = {}, f = b.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(o) {
            for (var s = o.words, a = o.sigBytes, h = [], _ = 0; _ < a; _++) {
              var S = s[_ >>> 2] >>> 24 - _ % 4 * 8 & 255;
              h.push((S >>> 4).toString(16)), h.push((S & 15).toString(16));
            }
            return h.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(o) {
            for (var s = o.length, a = [], h = 0; h < s; h += 2)
              a[h >>> 3] |= parseInt(o.substr(h, 2), 16) << 24 - h % 8 * 4;
            return new g.init(a, s / 2);
          }
        }, l = b.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(o) {
            for (var s = o.words, a = o.sigBytes, h = [], _ = 0; _ < a; _++) {
              var S = s[_ >>> 2] >>> 24 - _ % 4 * 8 & 255;
              h.push(String.fromCharCode(S));
            }
            return h.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(o) {
            for (var s = o.length, a = [], h = 0; h < s; h++)
              a[h >>> 2] |= (o.charCodeAt(h) & 255) << 24 - h % 4 * 8;
            return new g.init(a, s);
          }
        }, i = b.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(o) {
            try {
              return decodeURIComponent(escape(l.stringify(o)));
            } catch {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(o) {
            return l.parse(unescape(encodeURIComponent(o)));
          }
        }, d = y.BufferedBlockAlgorithm = m.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new g.init(), this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(o) {
            typeof o == "string" && (o = i.parse(o)), this._data.concat(o), this._nDataBytes += o.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(o) {
            var s, a = this._data, h = a.words, _ = a.sigBytes, S = this.blockSize, C = S * 4, x = _ / C;
            o ? x = n.ceil(x) : x = n.max((x | 0) - this._minBufferSize, 0);
            var N = x * S, P = n.min(N * 4, _);
            if (N) {
              for (var W = 0; W < N; W += S)
                this._doProcessBlock(h, W);
              s = h.splice(0, N), a.sigBytes -= P;
            }
            return new g.init(s, P);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var o = m.clone.call(this);
            return o._data = this._data.clone(), o;
          },
          _minBufferSize: 0
        });
        y.Hasher = d.extend({
          /**
           * Configuration options.
           */
          cfg: m.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(o) {
            this.cfg = this.cfg.extend(o), this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            d.reset.call(this), this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(o) {
            return this._append(o), this._process(), this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(o) {
            o && this._append(o);
            var s = this._doFinalize();
            return s;
          },
          blockSize: 16,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(o) {
            return function(s, a) {
              return new o.init(a).finalize(s);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(o) {
            return function(s, a) {
              return new A.HMAC.init(o, a).finalize(s);
            };
          }
        });
        var A = p.algo = {};
        return p;
      }(Math);
      return r;
    });
  }(Y)), Y.exports;
}
(function(e, t) {
  (function(r, n) {
    e.exports = n(he());
  })(q, function(r) {
    return function() {
      var n = r, u = n.lib, c = u.WordArray, v = n.enc;
      v.Base64url = {
        /**
         * Converts a word array to a Base64url string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @param {boolean} urlSafe Whether to use url safe
         *
         * @return {string} The Base64url string.
         *
         * @static
         *
         * @example
         *
         *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
         */
        stringify: function(p, y) {
          y === void 0 && (y = !0);
          var m = p.words, g = p.sigBytes, b = y ? this._safe_map : this._map;
          p.clamp();
          for (var f = [], l = 0; l < g; l += 3)
            for (var i = m[l >>> 2] >>> 24 - l % 4 * 8 & 255, d = m[l + 1 >>> 2] >>> 24 - (l + 1) % 4 * 8 & 255, A = m[l + 2 >>> 2] >>> 24 - (l + 2) % 4 * 8 & 255, o = i << 16 | d << 8 | A, s = 0; s < 4 && l + s * 0.75 < g; s++)
              f.push(b.charAt(o >>> 6 * (3 - s) & 63));
          var a = b.charAt(64);
          if (a)
            for (; f.length % 4; )
              f.push(a);
          return f.join("");
        },
        /**
         * Converts a Base64url string to a word array.
         *
         * @param {string} base64Str The Base64url string.
         *
         * @param {boolean} urlSafe Whether to use url safe
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
         */
        parse: function(p, y) {
          y === void 0 && (y = !0);
          var m = p.length, g = y ? this._safe_map : this._map, b = this._reverseMap;
          if (!b) {
            b = this._reverseMap = [];
            for (var f = 0; f < g.length; f++)
              b[g.charCodeAt(f)] = f;
          }
          var l = g.charAt(64);
          if (l) {
            var i = p.indexOf(l);
            i !== -1 && (m = i);
          }
          return B(p, m, b);
        },
        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
      };
      function B(p, y, m) {
        for (var g = [], b = 0, f = 0; f < y; f++)
          if (f % 4) {
            var l = m[p.charCodeAt(f - 1)] << f % 4 * 2, i = m[p.charCodeAt(f)] >>> 6 - f % 4 * 2, d = l | i;
            g[b >>> 2] |= d << 24 - b % 4 * 8, b++;
          }
        return c.create(g, b);
      }
    }(), r.enc.Base64url;
  });
})(ue);
var ze = ue.exports;
const Ue = /* @__PURE__ */ ce(ze);
var fe = { exports: {} };
(function(e, t) {
  (function(r, n) {
    e.exports = n(he());
  })(q, function(r) {
    return function(n) {
      var u = r, c = u.lib, v = c.WordArray, B = c.Hasher, p = u.algo, y = [], m = [];
      (function() {
        function f(A) {
          for (var o = n.sqrt(A), s = 2; s <= o; s++)
            if (!(A % s))
              return !1;
          return !0;
        }
        function l(A) {
          return (A - (A | 0)) * 4294967296 | 0;
        }
        for (var i = 2, d = 0; d < 64; )
          f(i) && (d < 8 && (y[d] = l(n.pow(i, 1 / 2))), m[d] = l(n.pow(i, 1 / 3)), d++), i++;
      })();
      var g = [], b = p.SHA256 = B.extend({
        _doReset: function() {
          this._hash = new v.init(y.slice(0));
        },
        _doProcessBlock: function(f, l) {
          for (var i = this._hash.words, d = i[0], A = i[1], o = i[2], s = i[3], a = i[4], h = i[5], _ = i[6], S = i[7], C = 0; C < 64; C++) {
            if (C < 16)
              g[C] = f[l + C] | 0;
            else {
              var x = g[C - 15], N = (x << 25 | x >>> 7) ^ (x << 14 | x >>> 18) ^ x >>> 3, P = g[C - 2], W = (P << 15 | P >>> 17) ^ (P << 13 | P >>> 19) ^ P >>> 10;
              g[C] = N + g[C - 7] + W + g[C - 16];
            }
            var de = a & h ^ ~a & _, le = d & A ^ d & o ^ A & o, pe = (d << 30 | d >>> 2) ^ (d << 19 | d >>> 13) ^ (d << 10 | d >>> 22), ve = (a << 26 | a >>> 6) ^ (a << 21 | a >>> 11) ^ (a << 7 | a >>> 25), te = S + ve + de + m[C] + g[C], ge = pe + le;
            S = _, _ = h, h = a, a = s + te | 0, s = o, o = A, A = d, d = te + ge | 0;
          }
          i[0] = i[0] + d | 0, i[1] = i[1] + A | 0, i[2] = i[2] + o | 0, i[3] = i[3] + s | 0, i[4] = i[4] + a | 0, i[5] = i[5] + h | 0, i[6] = i[6] + _ | 0, i[7] = i[7] + S | 0;
        },
        _doFinalize: function() {
          var f = this._data, l = f.words, i = this._nDataBytes * 8, d = f.sigBytes * 8;
          return l[d >>> 5] |= 128 << 24 - d % 32, l[(d + 64 >>> 9 << 4) + 14] = n.floor(i / 4294967296), l[(d + 64 >>> 9 << 4) + 15] = i, f.sigBytes = l.length * 4, this._process(), this._hash;
        },
        clone: function() {
          var f = B.clone.call(this);
          return f._hash = this._hash.clone(), f;
        }
      });
      u.SHA256 = B._createHelper(b), u.HmacSHA256 = B._createHmacHelper(b);
    }(Math), r.SHA256;
  });
})(fe);
var He = fe.exports;
const Pe = /* @__PURE__ */ ce(He), Oe = (e, t) => {
  const {
    client_id: r,
    redirect_uri: n,
    scope: u,
    state: c,
    chainId: v,
    chain: B,
    network: p,
    address: y,
    signature: m
  } = e, g = y ? {
    address: y,
    ...m !== void 0 ? { signature: m } : {},
    ...v !== void 0 || B !== void 0 ? { chain: v ? ee(v) : B } : {},
    ...v !== void 0 || p !== void 0 ? { network: v ? ae(v) : p } : {}
  } : {};
  return Z({
    client_id: r,
    redirect_uri: n,
    ...u !== void 0 ? { scope: u } : {},
    ...c !== void 0 ? { state: c } : {},
    code_challenge: t,
    code_challenge_method: "S256",
    response_type: "code",
    ...g
  });
}, Te = () => {
  let e = "";
  const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", r = t.length;
  let n = 0;
  for (; n < 128; )
    e += t.charAt(Math.floor(Math.random() * r)), n += 1;
  return e;
}, Me = (e) => Ue.stringify(Pe(e)), oe = (e, t) => {
  const r = Te(), n = Me(r);
  return localStorage.setItem(M, r || ""), `${e}/auth?${Oe(t, n)}`;
}, se = () => {
  const e = window.location.href;
  if (!e || !(e != null && e.includes("?")))
    return;
  const [t, r] = e.split("?");
  r && window.history.replaceState(null, "", t);
}, ie = (e) => e.code != null, Le = (e) => e.refresh_token != null, Ne = (e) => e.client_secret != null, je = async (e, t, r, n) => {
  const u = await fetch(`${e}`, {
    method: t,
    headers: n,
    body: r
  });
  let c;
  const v = await u.text();
  try {
    c = JSON.parse(v);
  } catch {
    throw v;
  }
  if (!u.ok)
    throw c;
  return c;
}, T = typeof window > "u";
var z, F, L, H, U, O, j, E, $, V, G, J;
class De {
  constructor(t) {
    /**
     * {@link https://monerium.dev/api-docs#operation/auth-token}
     */
    R(this, O);
    // -- Helper Methods
    R(this, E);
    R(this, z, void 0);
    R(this, F, void 0);
    /** The socket will be available after subscribing to an event */
    R(this, L, void 0);
    R(this, H, void 0);
    R(this, U, void 0);
    R(this, V, void 0);
    R(this, G, void 0);
    R(this, J, void 0);
    if (I(this, H, /* @__PURE__ */ new Map()), this.isAuthorized = !!this.bearerProfile, I(this, V, async (r, n, u) => {
      const c = localStorage.getItem(M) || "";
      if (!c)
        throw new Error("Code verifier not found");
      return this.codeVerifier = c, localStorage.removeItem(M), await k(this, O, j).call(this, {
        code: u,
        redirect_uri: n,
        client_id: r,
        code_verifier: c
      });
    }), I(this, G, async ({
      clientId: r,
      clientSecret: n
    }) => await k(this, O, j).call(this, {
      client_id: r,
      client_secret: n
    })), I(this, J, async (r, n) => await k(this, O, j).call(this, {
      refresh_token: n,
      client_id: r
    })), this.subscribeToOrderNotifications = () => {
      var u, c;
      const r = `${w(this, z).wss}/profiles/${(u = this.bearerProfile) == null ? void 0 : u.profile}/orders?access_token=${(c = this.bearerProfile) == null ? void 0 : c.access_token}`, n = new WebSocket(r);
      return n.addEventListener("open", () => {
        console.info(`Socket connected: ${r}`);
      }), n.addEventListener("error", (v) => {
        throw console.error(v), new Error(`Socket error: ${r}`);
      }), n.addEventListener("message", (v) => {
        var p;
        const B = JSON.parse(v.data);
        (p = w(this, H).get(B.meta.state)) == null || p(
          B
        );
      }), n.addEventListener("close", () => {
        console.info(`Socket connection closed: ${r}`);
      }), n;
    }, this.auth = async (r) => await k(this, O, j).call(this, r), this.connect = async (r) => await k(this, O, j).call(this, r), this.getAuthFlowURI = (r) => {
      const n = oe(w(this, z).api, r);
      return this.codeVerifier = localStorage.getItem(M), n;
    }, this.pkceRequest = (r) => this.getAuthFlowURI(r), this.getEnvironment = () => w(this, z), !t) {
      I(this, z, K.environments.sandbox);
      return;
    }
    if (typeof t == "string")
      I(this, z, K.environments[t]);
    else if (I(this, z, K.environments[t.environment || "sandbox"]), T) {
      const { clientId: r, clientSecret: n } = t;
      I(this, U, {
        clientId: r,
        clientSecret: n
      });
    } else {
      const { clientId: r, redirectUrl: n } = t;
      I(this, U, {
        clientId: r,
        redirectUrl: n
      });
    }
  }
  /**
   * Construct the url to the authorization code flow,
   * Code Verifier needed for the code challenge is stored in local storage
   * For automatic wallet link, add the following properties: `address`, `signature` & `chainId`
   * @returns string
   * {@link https://monerium.dev/api-docs#operation/auth}
   */
  async authorize(t) {
    var c, v;
    const r = (t == null ? void 0 : t.clientId) || ((c = w(this, U)) == null ? void 0 : c.clientId), n = (t == null ? void 0 : t.redirectUrl) || ((v = w(this, U)) == null ? void 0 : v.redirectUrl);
    if (!r)
      throw new Error("Missing ClientId");
    if (!n)
      throw new Error("Missing RedirectUrl");
    const u = oe(w(this, z).api, {
      client_id: r,
      redirect_uri: n,
      address: t == null ? void 0 : t.address,
      signature: t == null ? void 0 : t.signature,
      chainId: t == null ? void 0 : t.chainId
    });
    window.location.replace(u);
  }
  /**
   * Get access to the API
   * @param {AuthorizationCodeCredentials | ClientCredentials} client - the client credentials
   * @returns boolean to indicate if access has been granted
   */
  async getAccess(t) {
    var B, p, y;
    const r = (t == null ? void 0 : t.clientId) || ((B = w(this, U)) == null ? void 0 : B.clientId);
    if ((t == null ? void 0 : t.clientSecret) || ((p = w(this, U)) == null ? void 0 : p.clientSecret)) {
      if (!T)
        throw new Error("Only use client credentials on server side");
      return await w(this, G).call(this, w(this, U)), !!this.bearerProfile;
    }
    const u = (t == null ? void 0 : t.redirectUrl) || ((y = w(this, U)) == null ? void 0 : y.redirectUrl);
    if (!r)
      throw new Error("Missing ClientId");
    if (T)
      throw new Error("This only works client side");
    const c = new URLSearchParams(window.location.search).get("code") || void 0, v = localStorage.getItem(D) || void 0;
    return v ? await w(this, J).call(this, r, v) : c && await w(this, V).call(this, r, u, c), !!this.bearerProfile;
  }
  // -- Read Methods
  /**
   * {@link https://monerium.dev/api-docs#operation/auth-context}
   */
  getAuthContext() {
    return k(this, E, $).call(this, "get", "auth/context");
  }
  /**
     * {@link https://monerium.dev/api-docs#operation/profile}
     * @param {string} profileId - the id of the profile to fetch.
  
     */
  getProfile(t) {
    return k(this, E, $).call(this, "get", `profiles/${t}`);
  }
  /**
   * {@link https://monerium.dev/api-docs#operation/profile-balances}
   * @param {string=} profileId - the id of the profile to fetch balances.
   */
  getBalances(t) {
    return t ? k(this, E, $).call(this, "get", `profiles/${t}/balances`) : k(this, E, $).call(this, "get", "balances");
  }
  /**
   * {@link https://monerium.dev/api-docs#operation/orders}
   */
  getOrders(t) {
    const r = Z(t);
    return k(this, E, $).call(this, "get", `orders?${r}`);
  }
  /**
   * {@link https://monerium.dev/api-docs#operation/order}
   */
  getOrder(t) {
    return k(this, E, $).call(this, "get", `orders/${t}`);
  }
  /**
   * {@link https://monerium.dev/api-docs#operation/tokens}
   */
  getTokens() {
    return k(this, E, $).call(this, "get", "tokens");
  }
  // -- Write Methods
  /**
   * {@link https://monerium.dev/api-docs#operation/profile-addresses}
   */
  linkAddress(t, r) {
    return r = Q(r), r.accounts = r.accounts.map((n) => Q(n)), k(this, E, $).call(this, "post", `profiles/${t}/addresses`, JSON.stringify(r));
  }
  /**
   * {@link https://monerium.dev/api-docs#operation/post-orders}
   */
  placeOrder(t, r) {
    const n = {
      kind: "redeem",
      currency: "eur",
      ...Q(t),
      counterpart: {
        ...t.counterpart,
        identifier: Q(t.counterpart.identifier)
      }
    };
    return r ? k(this, E, $).call(this, "post", `profiles/${r}/orders`, JSON.stringify(n)) : k(this, E, $).call(this, "post", "orders", JSON.stringify(n));
  }
  /**
   * {@link https://monerium.dev/api-docs#operation/supporting-document}
   */
  uploadSupportingDocument(t) {
    const r = Z(
      t
    );
    return k(this, E, $).call(this, "post", "files/supporting-document", r, !0);
  }
  // -- Notifications
  async connectOrderSocket() {
    var t;
    (t = this.bearerProfile) != null && t.access_token && w(this, H).size > 0 && I(this, L, this.subscribeToOrderNotifications());
  }
  /**
   * Cleanups the socket and the subscriptions
   */
  async disconnect() {
    var t;
    T || localStorage.removeItem(M), w(this, H).clear(), (t = w(this, L)) == null || t.close(), I(this, F, void 0), this.bearerProfile = void 0;
  }
  /**
   * Revokes access
   */
  async revokeAccess() {
    T || localStorage.removeItem(D), this.disconnect();
  }
  /**
   * Subscribe to MoneriumEvent to receive notifications using the Monerium API (WebSocket)
   * We are setting a subscription map because we need the user to have a token to start the WebSocket connection
   * {@link https://monerium.dev/api-docs#operation/profile-orders-notifications}
   * @param event The event to subscribe to
   * @param handler The handler to be called when the event is triggered
   */
  subscribeOrders(t, r) {
    w(this, H).set(t, r);
  }
  /**
   * Unsubscribe from MoneriumEvent and close the socket if there are no more subscriptions
   * @param event The event to unsubscribe from
   */
  unsubscribeOrders(t) {
    var r;
    w(this, H).delete(t), w(this, H).size === 0 && ((r = w(this, L)) == null || r.close(), I(this, L, void 0));
  }
}
z = new WeakMap(), F = new WeakMap(), L = new WeakMap(), H = new WeakMap(), U = new WeakMap(), O = new WeakSet(), j = async function(t) {
  let r;
  if (ie(t))
    r = { ...t, grant_type: "authorization_code" };
  else if (Le(t))
    r = { ...t, grant_type: "refresh_token" };
  else if (Ne(t))
    r = { ...t, grant_type: "client_credentials" };
  else
    throw new Error("Authorization grant type could not be detected.");
  return await k(this, E, $).call(this, "post", "auth/token", r, !0).then((n) => {
    var u;
    this.bearerProfile = n, this.isAuthorized = !!n, I(this, F, `Bearer ${n == null ? void 0 : n.access_token}`), T || window.localStorage.setItem(
      D,
      ((u = this.bearerProfile) == null ? void 0 : u.refresh_token) || ""
    );
  }).catch((n) => {
    throw T || (localStorage.removeItem(M), localStorage.removeItem(D), se()), new Error(n == null ? void 0 : n.message);
  }), ie(t) && se(), this.bearerProfile;
}, E = new WeakSet(), $ = async function(t, r, n, u) {
  return je(
    `${w(this, z).api}/${r}`,
    t,
    u ? Z(n) : n,
    {
      Authorization: w(this, F) || "",
      "Content-Type": `application/${u ? "x-www-form-urlencoded" : "json"}`
    }
  );
}, V = new WeakMap(), G = new WeakMap(), J = new WeakMap();
export {
  Se as AccountState,
  we as Currency,
  be as KYCOutcome,
  _e as KYCState,
  De as MoneriumClient,
  ke as OrderKind,
  Ce as OrderState,
  Be as PaymentStandard,
  me as Permission,
  ye as ProfileType,
  We as constants,
  ee as getChain,
  ae as getNetwork,
  Fe as placeOrderMessage,
  re as rfc3339
};
